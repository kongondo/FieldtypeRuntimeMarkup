<?php

/**
 * FieldtypeRuntimeMarkup for ProcessWire.
 *
 * ProcessWire Fieldtype that allows markup to be dynamically returned from custom PHP snippet
 * to be output in the page editor and frontend (via API).
 *
 * Note that this is a runtime-only field and can't be queried via selectors since its value
 * only exists at runtime. 
 *
 * This fieldtype extends FieldtypeText so that it can reuse the TextFormatters 
 * functionality already implemented there. 
 * 
 * @author Kongondo <kongondo@gmail.com>
 * @sponsored by Andrey Valiev
 * 
 * Includes some code from from Ryan Cramer's FieldtypeConcat. 
 *
 * Lincensed under GNU/GPL v2.
 *
 * https://github.com/kongondo/FieldtypeRuntimeMarkup
 * Created August 2015
 *
 * ProcessWire 2.x 
 * Copyright (C) 2015 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 *
 *
 */

class FieldtypeRuntimeMarkup extends FieldtypeText {

	public static function getModuleInfo() {
		return array(
			'title' => 'RuntimeMarkup',
			'author' => 'Francis Otieno (Kongondo)',
			'version' => 003,
			'href' => 'https://processwire.com/talk/topic/10804-module-runtimemarkup-fieldtype-inputfield/',
			'summary' => 'Allows rendering of custom markup within page editor and frontend via custom PHP snippet set in the field.',			
			);
	}

	public function init() {
		$this->set('runtimeCodeMode', '');// @todo...needed?
	}

	/**
	 * Return the required Inputfield used to populate a field of this type
	 *
	 */
	public function getInputfield(Page $page, Field $field) {

		$inputfield = $this->wire('modules')->get('InputfieldRuntimeMarkup');

		// store the page using this field (page being edited in our case) for use in the inputfield
		$inputfield->setPage($page);//  @note: this is a method in InputfieldRuntimeMarkup

		// store this field's name for use in InputfieldRuntimeMarkup
		$inputfield->set('fieldName', $field->name);

		## direct code vs render file mode
		$inputfield->set('runtimeCodeMode', $field->runtimeCodeMode);
		
		## PHP code mode ##
		$inputfield->set('runtimeCustomPHPCode', $field->runtimeCustomPHPCode);
		
		## render file mode ##

		// default path
		$inputfield->set('defaultPath', $field->defaultPath);

		// PHP file
		$inputfield->set('renderPHPFileMode', $field->renderPHPFileMode);
		$inputfield->set('renderPHPFile', $field->renderPHPFile);
		// JS file
		$inputfield->set('renderJSFileMode', $field->renderJSFileMode);
		$inputfield->set('renderJSFile', $field->renderJSFile);
		// CSS file
		$inputfield->set('renderCSSFileMode', $field->renderCSSFileMode);
		$inputfield->set('renderCSSFile', $field->renderCSSFile);

		return $inputfield;
	}

	/**
	 *
	 * Return this field's settings as displayed in Details Tab.
	 *
	 */
	public function ___getConfigInputfields(Field $field) {
		
		$inputfields = parent::___getConfigInputfields($field);

		$modules = $this->wire('modules');

		// radios: select runtime code mode [custom php vs render file]
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'runtimeCodeMode');
		$f->attr('value', $field->runtimeCodeMode ? $field->runtimeCodeMode : 1);
		$f->label =  $this->_('PHP Runtime Code Mode');
		$f->description = $this->_('Select how PHP runtime code will be specified.');
		$f->notes = $this->_('It is recommended that you choose option 2 to render PHP files. That offers better flexibility and control.');
		$radioOptions = array (
						 1 => __('Paste PHP code'),
						 2 => __('Render PHP file(s) (recommended)'),
	 	);

		$f->addOptions($radioOptions);

		$inputfields->append($f);

		## - PHP - ##

		// textarea: custom PHP code
		$f = $modules->get('InputfieldTextarea'); 
		$f->attr('name', 'runtimeCustomPHPCode');
		$f->attr('value', $field->runtimeCustomPHPCode); 
		$f->label = $this->_('Custom PHP code to generate markup');
		$f->description = $this->_('Enter valid PHP code to return custom markup. This statement has access to the $page and $pages API variables, where $page refers to the page being edited. The snippet should only return strings and integers. Anything else will result in an error.');
		$f->notes = $this->_('Example: return $page->parent->parent->title;');
		$f->showIf = 'runtimeCodeMode=1';
		$f->requiredIf = 'runtimeCodeMode=1';

		$inputfields->append($f);

		// radios: default file path for wireRenderFile().
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'defaultPath');
		$f->attr('value', $field->defaultPath ? $field->defaultPath : 1);
		$f->label =  $this->_('Files Root Path');
		$f->description = $this->_('Specify root path of files below.');
		$f->notes = $this->_('Any PHP, JavaScript or CSS files specified in settings below must descend from either of these two root path options. Files in sub-folders are OK as long as those reside in one of the two root paths.');
		#$f->showIf = 'runtimeCodeMode=2';
		#$f->requiredIf = 'runtimeCodeMode=2';	
		$radioOptions = array (
						 1 => __('/site/templates/'),
						 2 => __('/site/modules/'),
	 	);

		$f->addOptions($radioOptions);

		$inputfields->append($f);

		// radios: render PHP file with same name as this field or custom named
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'renderPHPFileMode');
		$f->attr('value', $field->renderPHPFileMode ? $field->renderPHPFileMode : 1);
		$f->label =  $this->_('Render PHP File Mode');
		$f->description = $this->_('Specify name of PHP file to render.');
		$notes = $this->_("If you select option 1, the PHP file must have an identical name to this field. A '.php' extension is assumed hence does no need to be specified. If the file is named differently or has a different extension (e.g. my-file.inc) or you want to render several files, use option 2 instead.");
		$f->notes = $notes;
		$f->showIf = 'runtimeCodeMode=2';
		$f->requiredIf = 'runtimeCodeMode=2';	
		$radioOptions = array (
						 1 => __('PHP file has identical name to this field'),
						 2 => __('PHP file has different name'),
	 	);

		$f->addOptions($radioOptions);

		$inputfields->append($f);

		// text: name of php file to render 
		$f = $modules->get('InputfieldText');
		$f->attr('name', 'renderPHPFile');
		$f->attr('value', $field->renderPHPFile);
		$f->label = $this->_('Render PHP File');
		$f->description = $this->_('Enter comma-separated names and/or paths of PHP files to render.');
		$f->notes = $this->_('The PHP files must reside somewhere in the Root Path selected above. If a file is in a sub-folder, enter the relative path. For example: **includes/my-file,inc/tools/my-file.php,my-file2.inc**.');
		$f->showIf = 'runtimeCodeMode=2, renderPHPFileMode=2';
		$f->requiredIf = 'renderPHPFileMode=2';

		$inputfields->append($f);

		## - JavaScript - ##

		// radios: render JavaScript file with same name as this field or custom named
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'renderJSFileMode');
		$f->attr('value', $field->renderJSFileMode ? $field->renderJSFileMode : 1);
		$f->label =  $this->_('Add JavaScript File Mode');
		$f->description = $this->_('Specify name of JavaScript file to add.');
		$notes = $this->_("If you select option 2, the JavaScript file must have an identical name to this field. A '.js' extension is assumed hence does no need to be specified. If the file is named differently or you want to add several files, use option 3 instead.");
		$f->notes = $notes;
		#$f->showIf = 'runtimeCodeMode=2';
		#$f->requiredIf = 'runtimeCodeMode=2';	
		$radioOptions = array (
						 1 => __("Don't add JavaScript file"),
						 2 => __('JavaScript file has identical name to this field'),
						 3 => __('JavaScript file has different name'),
						 
	 	);

		$f->addOptions($radioOptions);

		$inputfields->append($f);

		// text: name of JavaScript file to render 
		$f = $modules->get('InputfieldText');
		$f->attr('name', 'renderJSFile');
		$f->attr('value', $field->renderJSFile);
		$f->label = $this->_('Add JavaScript File(s)');
		$f->description = $this->_('Enter comma-separated names and/or paths of JavaScript files to add.');
		$f->notes = $this->_('The JavaScript files must reside somewhere in the Root Path selected above. If a file is in a sub-folder, enter the relative path. For example: **scripts/my-file,includes/js/my-file.js,my-file2**.');
		#$f->showIf = 'runtimeCodeMode=2, renderJSFileMode=3';
		$f->showIf = 'renderJSFileMode=3';
		$f->requiredIf = 'renderJSFileMode=3';

		$inputfields->append($f);

		## - CSS - ##

		// radios: render JavaScript file with same name as this field or custom named
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'renderCSSFileMode');
		$f->attr('value', $field->renderCSSFileMode ? $field->renderCSSFileMode : 1);
		$f->label =  $this->_('Add CSS File Mode');
		$f->description = $this->_('Specify name of CSS file to add.');
		$notes = $this->_("If you select option 2, the CSS file must have an identical name to this field. A '.css' extension is assumed hence does no need to be specified. If the file is named differently or you want to add several files, use option 3 instead.");
		$f->notes = $notes;
		#$f->showIf = 'runtimeCodeMode=2';
		#$f->requiredIf = 'runtimeCodeMode=2';	
		$radioOptions = array (
						 1 => __("Don't add CSS file"),
						 2 => __('CSS file has identical name to this field'),
						 3 => __('CSS file has different name'),
	 	);

		$f->addOptions($radioOptions);

		$inputfields->append($f);

		// text: name of JavaScript file to render 
		$f = $modules->get('InputfieldText');
		$f->attr('name', 'renderCSSFile');
		$f->attr('value', $field->renderCSSFile);
		$f->label = $this->_('Add CSS File(s)');
		$f->description = $this->_('Enter comma-separated names and/or paths of CSS files to add.');
		$f->notes = $this->_('The CSS files must reside somewhere in the Root Path selected above. If a file is in a sub-folder, enter the relative path. For example: **styles/my-file,includes/css/my-file.css,my-file2**.');
		#$f->showIf = 'runtimeCodeMode=2, renderCSSFileMode=3';
		$f->showIf = 'renderCSSFileMode=3';
		$f->requiredIf = 'renderCSSFileMode=3';

		$inputfields->append($f);
		
		return $inputfields; 
	}

	/**
	 * Create the populated runtime markup string for the given $field on $page
	 *
	 * @return str Non-formatted markup string
	 *
	 */
	protected function renderMarkup(Page $page, Field $field) {

		// @note: currently, only runtime PHP code returned here, i.e. no rendering PHP files
		if(1 == $field->runtimeCodeMode && $field->runtimeCustomPHPCode) {
			// locally scope $pages to eval()
			$pages = $this->wire('pages');

			$str = eval($field->runtimeCustomPHPCode);

			// since we are dealing with custom PHP code but also want to make sure that only markup is returned
			// if eval() returns anything other than a string or an integer, we throw an error (e.g. if an object or array is returned)
			if (is_string($str) || is_int($str)) return $str;
			// we need to check if we are in admin. Otherwise with an error, in the frontend the name of the the Fieldtype is returned if we echo out the field
			elseif($this->wire('process')->className() == 'ProcessPageEdit') return $this->error($this->_('Only strings and integers should be returned by your custom code! Check if your code is valid.'));
		}		
		
	}

	/**
	 * Render a markup string of the value
	 * 
	 * This is important for correctly rendering markup output in listers.
	 *
	 * @param Page $page Page that $value comes from
	 * @param Field $field Field that $value comes from
	 * @param mixed $value Optionally specify the $page->getFormatted(value), value must be a formatted value. 
	 * 	If null or not specified (recommended), it will be retrieved automatically.
	 * @param string $property Optionally specify the property or index to render. If omitted, entire value is rendered.
	 * @return string|MarkupFieldtype Returns a string or object that can be output as a string, ready for output.
	 *
	 */
	public function ___markupValue(Page $page, Field $field, $value = null, $property = '') {
		return $value;
	}

	###########################################################################################

	/**
	 * The following functions are defined as replacements to keep this fieldtype out of the DB
	 *
	 */

	public function sanitizeValue(Page $page, Field $field, $value) {
		return $value; 
	}

	public function ___wakeupValue(Page $page, Field $field, $value) {
		return $this->renderMarkup($page, $field);
	}

	public function ___sleepValue(Page $page, Field $field, $value) {
		return $this->renderMarkup($page, $field);
	}

	public function getLoadQuery(Field $field, DatabaseQuerySelect $query) {
		// prevent loading from DB
		return $query; 
	}

	public function ___loadPageField(Page $page, Field $field) {
		// generate value at runtime rather than loading from DB
		return $this->renderMarkup($page, $field); 
	}

	public function ___savePageField(Page $page, Field $field) {
		// prevent saving of field
		return true;
	}

	public function ___deletePageField(Page $page, Field $field) {
		// deleting of page field not necessary
		return true; 
	}

	public function ___deleteField(Field $field) {
		// deleting of field not necessary
		return true; 
	}

	public function getDatabaseSchema(Field $field) {
		// no database schema necessary
		return array();
	}

	public function ___createField(Field $field) {
		// nothing necessary to create the field
		return true; 
	}

	public function getMatchQuery($query, $table, $subfield, $operator, $value) {
		// we don't allow this field to be queried
		throw new WireException("Field '{$query->field->name}' is runtime and not queryable");
	}
	
	public function ___getCompatibleFieldtypes(Field $field) {
		// no fieldtypes are compatible
		return new Fieldtypes();
	}

	public function getLoadQueryAutojoin(Field $field, DatabaseQuerySelect $query) {
		// we don't allow this field to be autojoined
		return null;
	}


}

